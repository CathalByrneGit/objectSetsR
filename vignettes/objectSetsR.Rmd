---
title: "Working with Object Sets"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Working with Object Sets}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Overview

`objectSetsR` provides a lazy query algebra for ontology-aware datasets. You
define your ontology in `ontologySpecR`, connect to a DBI backend (such as
DuckDB), and compose `ObjectSet` operations without immediately executing
queries.

# Aviation demo example

We start by defining a small bundle that describes airports and flight routes,
then load sample data into an in-memory DuckDB database.

```{r create-context}
library(objectSetsR)
library(DBI)
library(duckdb)

bundle <- list(
  objects = list(
    list(
      id = "Airport",
      primaryKey = "airport_id",
      source = list(table = "airports"),
      properties = list(
        list(id = "airport_id", type = "string"),
        list(id = "country", type = "string"),
        list(id = "name", type = "string")
      )
    ),
    list(
      id = "FlightRoute",
      primaryKey = "route_id",
      source = list(table = "routes"),
      properties = list(
        list(id = "route_id", type = "string"),
        list(id = "origin_id", type = "string"),
        list(id = "destination_id", type = "string"),
        list(id = "stops", type = "integer")
      )
    )
  ),
  links = list(
    list(
      id = "RouteOrigin",
      from = "FlightRoute",
      to = "Airport",
      join = list(fromKeys = "origin_id", toKeys = "airport_id")
    ),
    list(
      id = "RouteDestination",
      from = "FlightRoute",
      to = "Airport",
      join = list(fromKeys = "destination_id", toKeys = "airport_id")
    )
  )
)

con <- DBI::dbConnect(duckdb::duckdb())

DBI::dbWriteTable(con, "airports", data.frame(
  airport_id = c("DUB", "JFK", "LHR"),
  country    = c("Ireland", "USA", "UK"),
  name       = c("Dublin", "John F Kennedy", "Heathrow"),
  stringsAsFactors = FALSE
))

DBI::dbWriteTable(con, "routes", data.frame(
  route_id       = c("R1", "R2", "R3", "R4"),
  origin_id      = c("DUB", "JFK", "LHR", "DUB"),
  destination_id = c("JFK", "DUB", "JFK", "LHR"),
  stops          = c(0L, 1L, 0L, 0L),
  stringsAsFactors = FALSE
))

ctx <- ontology_context(bundle, con)
ctx
```

# Filtering and collecting

`os_filter()` adds a lazy predicate. Nothing is executed until `os_collect()`.

```{r filter}
nonstop <- object_set(ctx, "FlightRoute") |>
  os_filter(stops == 0L)

os_collect(nonstop)
```

# Selecting properties

```{r select}
object_set(ctx, "Airport") |>
  os_select(airport_id, name) |>
  os_collect()
```

# Traversing links

`os_traverse()` follows a link to the target object type.

```{r traverse}
origins <- object_set(ctx, "FlightRoute") |>
  os_filter(stops == 0L) |>
  os_traverse("RouteOrigin") |>
  os_collect()
origins
```

`os_search_around()` traverses in reverse.

```{r search-around}
routes_from_dublin <- object_set(ctx, "Airport") |>
  os_filter(airport_id == "DUB") |>
  os_search_around("RouteOrigin") |>
  os_collect()
routes_from_dublin
```

# Set algebra

```{r set-algebra}
routes <- object_set(ctx, "FlightRoute")
from_dub <- routes |> os_filter(origin_id == "DUB")
nonstop  <- routes |> os_filter(stops == 0L)

os_union(from_dub, nonstop) |> os_collect()
os_intersect(from_dub, nonstop) |> os_collect()
```

# Aggregation

```{r aggregate}
object_set(ctx, "FlightRoute") |>
  os_aggregate(origin_id, .fns = list(n = dplyr::n())) |>
  os_collect()
```

# Deduplication and sorting

```{r distinct-arrange}
object_set(ctx, "FlightRoute") |>
  os_traverse("RouteOrigin") |>
  os_distinct() |>
  os_arrange(name) |>
  os_collect()
```

# Viewing the generated SQL

```{r show-query}
object_set(ctx, "FlightRoute") |>
  os_filter(stops == 0L) |>
  os_traverse("RouteOrigin") |>
  os_show_query()
```

```{r cleanup, include=FALSE}
DBI::dbDisconnect(con, shutdown = TRUE)
```
